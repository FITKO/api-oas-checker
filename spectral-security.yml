#
# See technical recommendations on Italian Guidelines:
#
# https://docs.italia.it/italia/piano-triennale-ict/lg-modellointeroperabilita-docs/it/bozza/doc/profili-di-interazione/regole-comuni-rest-soap.html#raccomandazioni-tecniche-per-rest
#
extends: spectral:oas

rules:
  array-boundaries:
    description: >-
      Array size should be limited to mitigate resource exhaustion attacks.

      This can be done using `maxItems` and `minItems`, like in the example

      below.


      ```

      Limited:
        type: array
        maxItems: 10
        items:
          type: string
          format: date
      ```


      You should ensure that the schema referenced in  `items` is constrained too.


      If you delegate input validation to a library or framework,

      be sure to test it thoroughly and ensure that it verifies `maxItems`.
    message: Schema of type array must specify maxItems and minItems. {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="array")]
    then:
      - field: maxItems
        function: defined
      - field: minItems
        function: defined
  number-boundaries:
    description: |-
      Numeric values should be limited in size to mitigate resource exhaustion
      using `maximum` and `minimum`.

      If you delegate input validation to a library or framework,
      be sure to test it thoroughly.
    message: Schema of type number or integer must specify a maximum and a minimum.
      {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="number")]
      - $.[?(@.type=="integer")]
    then:
      - field: maximum
        function: defined
      - field: minimum
        function: defined
  no-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow additionalProperties. Disable them with
      `additionalProperties: false` or constraint them."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="object" && @.additionalProperties==true)]
    then:
      - field: additionalProperties
        function: falsy
  no-default-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow additionalProperties. Disable them with
      `additionalProperties: false` or constraint them."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="object" && ! @.additionalProperties)]
    then:
      - field: additionalProperties
        function: defined
  constrained-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow additionalProperties. Disable them with
      `additionalProperties: false` or constraint them."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="object" && @.additionalProperties
        &&  @.additionalProperties!=true &&  @.additionalProperties!=false )]
    then:
      - field: maxProperties
        function: defined
  security-protection-get:
    description: >-
      Your API should be protected by a `security` rule either at

      global or operation level.

      Operations should be protected specially when they

      are tied to non-idempotent HTTP methods like `POST`, `PUT`, `PATCH` and `DELETE`.


      Security rules are defined in the `securityScheme` section.


      An example of a security rule applied at global level.


      ```

      security:

      - BasicAuth: []

      paths:
        /books: {}
        /users: {}
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
      ```


      An example of a security rule applied at operation level, which

      eventually overrides the global one


      ```

      paths:
        /books:
          post:
            security:
            - AccessToken: []
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
        AccessToken:
          scheme: http
          type: bearer
          bearerFormat: JWT
      ```
    message: The path {{path}} is not protected.
    formats:
      - oas3
    severity: info
    recommended: true
    given:
      - $.paths.*.get
    then:
      - field: security
        function: truthy
  security-protection-non-idempotent:
    description: >-
      Your API should be protected by a `security` rule either at

      global or operation level.

      Operations should be protected specially when they

      are tied to non-idempotent HTTP methods like `POST`, `PUT`, `PATCH` and `DELETE`.


      Security rules are defined in the `securityScheme` section.


      An example of a security rule applied at global level.


      ```

      security:

      - BasicAuth: []

      paths:
        /books: {}
        /users: {}
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
      ```


      An example of a security rule applied at operation level, which

      eventually overrides the global one


      ```

      paths:
        /books:
          post:
            security:
            - AccessToken: []
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
        AccessToken:
          scheme: http
          type: bearer
          bearerFormat: JWT
      ```
    message: The non-idempotent operation {{path}} is not protected
    formats:
      - oas3
    severity: error
    recommended: true
    given:
      - $.paths.*[?(@property.match(/^(post|put|patch|delete)/))]
    then:
      - field: security
        function: truthy
  string-maxlength:
    description: |-
      String length should be limited to avoid an attacker
      to send very long strings to your service.

      You can do this in different ways:
      - specify a `maxLength`
      - constraint the possible values with an `enum`
      - use a constrained `format` like `date` or `date-time`.

      A constrained string using the `date` format.

      ```
      ConstrainedString:
        type: string
        format: date
      ```

      Another constrained string using `maxLength`.
      You can always add further constraints using a
      `pattern` or a `format`.

      ```
      ZipCode:
        type: string
        maxLength: 5
        pattern: '[0-9]{5}'
      ```

      For further security, you can always limit string length even
      in conjunction with `format` and `pattern`.
    message: Strings (non enum) must specify a maximum length. {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $.[?(@.type=="string" && !@.enum && @.format!="date" && @.format
        !="date-time" )]
    then:
      - field: maxLength
        function: defined
  string-pattern-or-format-or-enum:
    description: |-
      String length should be limited to avoid an attacker
      to send very long strings to your service.

      You can do this in different ways:
      - specify a `maxLength`
      - constraint the possible values with an `enum`
      - use a constrained `format` like `date` or `date-time`.

      A constrained string using the `date` format.

      ```
      ConstrainedString:
        type: string
        format: date
      ```

      Another constrained string using `maxLength`.
      You can always add further constraints using a
      `pattern` or a `format`.

      ```
      ZipCode:
        type: string
        maxLength: 5
        pattern: '[0-9]{5}'
      ```

      For further security, you can always limit string length even
      in conjunction with `format` and `pattern`.
    message: Strings (non enum) must specify a pattern or a format. {{path}}
    formats:
      - oas3
    severity: hint
    recommended: true
    given:
      - $.[?(@.type=="string" && !@.enum && @.format!="date" && @.format
        !="date-time" )]
    then:
      function: schema
      functionOptions:
        schema:
          type: object
          anyOf:
            - required:
                - pattern
            - required:
                - format
          additionalProperties: true

